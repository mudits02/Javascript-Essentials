1. Temporal dead zone is basically the time period in which a let variable is hoisted and 
    till it was initalized.

2. Block in js basically when we are grouping multiple js statements to be used afterwards
    its done in between of {} and its the same how we write statments under if statement.

3 Let and const are in block scope that means that if they are declared in a block , then
    they can be accessed only in that particular block and not outisde it, but the var is
    declared globally.

4. Shadowing of var -> refer prac.js for that , basically if a variable is declared outisde
    first and then inside a block , we declare it as some other value , then the block
    value shadows or overwrites it and it shadows it in its global scope. this is done
    because both are pointing to the same memory location.

5. Shadowing happens in let and const too but there value only changes in the block where
    they are being re valued.

6. Shadowing behaves same in a scope of function.

7. Illegal Shadowing -> It means when we reassign a let declared globally through a var 
    inside a scope , it gives an syntax error while vice versa works fine. Both let and 
    const follow lexical scope. 

    let a = 10;
    {
        var a = 20; //this throws error
    }

    <--------->
    var a = 10;
    {
        let a = 20; //Works perfectly fine.
    }

    <------->
    const a = 20;
    {
        const a = 30; 
        console.log(a); // op-> 30
    }

    console.log(a); //op -> 20

8. Var can be declared and accessed globally. Let can be declared globally, but its 
    access is limited to the block in which it is declared. Variables declared using 
    var can be re-declared and updated within the same scope. Variables declared with 
    let can be updated but not re-declared within the same scope.

9. A closure is the combination of a function bundled together (enclosed) with references
    to its surrounding state (the lexical environment). In other words, a closure gives you 
    access to an outer function's scope from an inner function.

    Example in prac.js

10. In example of prac.js , closure means that since we are returning function y from
    func x , so technically , z has the function calling of only y and variable inside
    y is just printed but the defining is done in function x, so basically , it will
    print 10 because it remembers its lexical memeory and that is what is closure.
    So when we call z anywhere else in the program , a is still remembered and printed
    everytime because it remembers its lexical memory.

11. Also remember, in the closure code , the output becomes 100 because the real thing being
    printed here is the reference of a , not the value , since variables are executed in
    global scope , we see that console.log(a) refers the a of the global scope.

12. Differece between function statement and function expression is hoisiting.

13. Function statement and Function declaration is the same thing.

14. Anonymous function means namesless function (different from Arrow functions)
    They throw error when delcared directly (Syntax error). They are used when we have
    to use functions as a value (as declared in function expression example).

15. Function expression is basically when we are declaring a function inside of a variable
    but we are declaring the name of the function in the variable. It shows the output only
    when the varibale is called and not when that function is called because in JS , that
    function is declared in the local scope of the variable and not in the global scope.

16. When we are passing value inside a function , they are called arguements, i.e.
    we have delcared xyz(1 , 2) , so here 1 and 2 are arguements while 
    function xyz(param1 , param2){

    }

    param1 and param2 are parameters.

17. We can also pass a function as an arguement.

18. We can return an Anonymous function from a function

19. First class function means kind of ability to take functions as parameter , to pass 
    them as an arguement or return them from the function.

20. Functions are first class citizens -> ability to use functions like a value.

21. Callback functions are those function swhich are called as an arguement inside of
    a function(they are Anonymous).

22. Callback function help in making the synchronous js asynchronous.

23. A JavaScript callback is a function which is to be executed after another function
    has finished execution. A more formal definition would be - Any function that is
    passed as an argument to another function so that it can be executed in that other
    function is called as a callback function.

24. We use closure for data hiding.

25. Js is synchronous and single threaded.

26. Callback queue is basically a execution queue where all the callbacks are inserted
    and the event loop checks that is there any callback in the queue and it is schduled,
    if it finds one, it send it to the Call stack and it is executed.

27. In event_loop.js ,  when we are doing addEventListener , that function waits in the 
    Web API environment to get pressed and when pressed , it goes in the callback queue
    and then event loop checks for it and pushes it in the call stack and its executed

28. When we call the fetch() Web API , then initially it also waits for in the Web API
    environment until called , then it is sent to MicroTask Queue for execution , which 
    has a high priority than the Callback Queue and is executed first by the Event loop.

29. All the callbacks that come through promises are send to the MicroTask Queue and
    mutation observer too.

30. JavaScript Runtime environment -> An environment which enables to run Js on any machine
    Browser is able to execute js code because it has Js Runtime environment.

31. 












